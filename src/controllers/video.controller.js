const db = require('../config/db');
const fs = require('fs');
const path = require('path');

// @desc    Upload a video to a course
// @route   POST /api/videos
// @access  Public
const uploadVideo = async (req, res) => {
  const { title, description, courseId, sequenceOrder, tutorId, url, type, duration } = req.body;

  if (!tutorId) {
    return res.status(400).json({
      success: false,
      message: 'Tutor ID is required',
    });
  }

  try {
    // Check if the course exists and belongs to the tutor
    const courseCheck = await db.query(
      `SELECT * FROM courses WHERE id = $1 AND tutor_id = $2`,
      [courseId, tutorId]
    );

    if (courseCheck.rows.length === 0) {
      // Remove the uploaded file
      if (req.file) {
        fs.unlinkSync(req.file.path);
      }
      return res.status(404).json({
        success: false,
        message: 'Course not found or you are not authorized',
      });
    }

    let videoUrl = null;
    let videoDuration = duration || 0;

    // Handle different types of video sources
    if (type === 'external' && url) {
      // For external videos (YouTube, Vimeo, etc.)
      videoUrl = url;
    } else if (req.file) {
      // For uploaded video files
      videoUrl = `/uploads/${req.file.filename}`;
    } else {
      return res.status(400).json({
        success: false,
        message: 'Please provide either a video URL or upload a video file',
      });
    }

    // Insert video record
    const result = await db.query(
      `INSERT INTO videos 
      (course_id, title, description, video_url, sequence_order, duration) 
      VALUES ($1, $2, $3, $4, $5, $6) 
      RETURNING *`,
      [courseId, title, description, videoUrl, sequenceOrder || 1, videoDuration]
    );

    // Here you would normally call an AI service to generate transcription
    // For now, we're just creating a placeholder
    await db.query(
      `INSERT INTO transcripts (video_id, content, is_ai_generated)
      VALUES ($1, $2, $3)`,
      [result.rows[0].id, 'This is a placeholder transcript. In a real implementation, this would be generated by an AI service.', true]
    );

    res.status(201).json({
      success: true,
      video: result.rows[0],
    });
  } catch (error) {
    console.error(error);
    // Remove the uploaded file in case of error
    if (req.file) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (unlinkError) {
        console.error('Error deleting file:', unlinkError);
      }
    }
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message,
    });
  }
};

// @desc    Get all videos for a course
// @route   GET /api/videos/course/:courseId
// @access  Public
const getCourseVideos = async (req, res) => {
  try {
    const result = await db.query(
      `SELECT * FROM videos 
      WHERE course_id = $1 
      ORDER BY sequence_order`,
      [req.params.courseId]
    );

    res.json({
      success: true,
      count: result.rows.length,
      videos: result.rows,
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message,
    });
  }
};

// @desc    Get a single video with its transcript
// @route   GET /api/videos/:id
// @access  Public
const getVideo = async (req, res) => {
  try {
    // Get the video
    const videoResult = await db.query(
      `SELECT v.*, c.tutor_id, c.id as course_id
      FROM videos v
      JOIN courses c ON v.course_id = c.id
      WHERE v.id = $1`,
      [req.params.id]
    );

    if (videoResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Video not found',
      });
    }

    const video = videoResult.rows[0];

    // Get the transcript
    const transcriptResult = await db.query(
      `SELECT * FROM transcripts WHERE video_id = $1`,
      [req.params.id]
    );

    // Get transcript timestamps if available
    const timestampsResult = await db.query(
      `SELECT * FROM transcript_timestamps 
      WHERE transcript_id = $1 
      ORDER BY start_time`,
      [transcriptResult.rows[0]?.id || null]
    );

    res.json({
      success: true,
      video,
      transcript: transcriptResult.rows[0] || null,
      timestamps: timestampsResult.rows || [],
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message,
    });
  }
};

// @desc    Update video details
// @route   PUT /api/videos/:id
// @access  Public
const updateVideo = async (req, res) => {
  const { title, description, sequenceOrder, tutorId, url, type, duration } = req.body;

  if (!tutorId) {
    return res.status(400).json({
      success: false,
      message: 'Tutor ID is required',
    });
  }

  try {
    // Check if the video exists and belongs to the tutor's course
    const videoCheck = await db.query(
      `SELECT v.*, c.tutor_id 
      FROM videos v
      JOIN courses c ON v.course_id = c.id
      WHERE v.id = $1`,
      [req.params.id]
    );

    if (videoCheck.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Video not found',
      });
    }

    if (videoCheck.rows[0].tutor_id !== tutorId) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to update this video',
      });
    }

    let videoUrl = videoCheck.rows[0].video_url;
    let videoDuration = duration || videoCheck.rows[0].duration;

    // Handle different types of video sources
    if (type === 'external' && url) {
      // For external videos (YouTube, Vimeo, etc.)
      videoUrl = url;
    } else if (req.file) {
      // For uploaded video files
      // If replacing a file, delete the old one
      const oldVideoUrl = videoCheck.rows[0].video_url;
      if (oldVideoUrl && oldVideoUrl.startsWith('/uploads/')) {
        const oldVideoPath = path.join(__dirname, '../..', oldVideoUrl);
        if (fs.existsSync(oldVideoPath)) {
          try {
            fs.unlinkSync(oldVideoPath);
          } catch (err) {
            console.error('Failed to delete old video file:', err);
          }
        }
      }
      
      videoUrl = `/uploads/${req.file.filename}`;
    }

    // Update the video
    const result = await db.query(
      `UPDATE videos 
      SET title = COALESCE($1, title), 
          description = COALESCE($2, description), 
          sequence_order = COALESCE($3, sequence_order),
          video_url = COALESCE($4, video_url),
          duration = COALESCE($5, duration),
          updated_at = NOW()
      WHERE id = $6
      RETURNING *`,
      [title, description, sequenceOrder, videoUrl, videoDuration, req.params.id]
    );

    res.json({
      success: true,
      video: result.rows[0],
    });
  } catch (error) {
    console.error(error);
    // Remove the uploaded file in case of error
    if (req.file) {
      try {
        fs.unlinkSync(req.file.path);
      } catch (err) {
        console.error('Failed to delete uploaded file after error:', err);
      }
    }
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message,
    });
  }
};

// @desc    Delete a video
// @route   DELETE /api/videos/:id
// @access  Public
const deleteVideo = async (req, res) => {
  const { tutorId } = req.body;

  if (!tutorId) {
    return res.status(400).json({
      success: false,
      message: 'Tutor ID is required',
    });
  }

  try {
    // Check if the video exists and belongs to the tutor's course
    const videoCheck = await db.query(
      `SELECT v.*, c.tutor_id 
      FROM videos v
      JOIN courses c ON v.course_id = c.id
      WHERE v.id = $1`,
      [req.params.id]
    );

    if (videoCheck.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Video not found',
      });
    }

    if (videoCheck.rows[0].tutor_id !== tutorId) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to delete this video',
      });
    }

    // Get the video path to delete the file
    const videoUrl = videoCheck.rows[0].video_url;
    const videoPath = path.join(__dirname, '../..', videoUrl);

    // Delete the video from the database (cascade will handle transcripts)
    await db.query(`DELETE FROM videos WHERE id = $1`, [req.params.id]);

    // Delete the file if it exists
    if (fs.existsSync(videoPath)) {
      fs.unlinkSync(videoPath);
    }

    res.json({
      success: true,
      message: 'Video deleted successfully',
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message,
    });
  }
};

// @desc    Update video progress
// @route   PUT /api/videos/:id/progress
// @access  Public
const updateProgress = async (req, res) => {
  const { position, isCompleted, studentId } = req.body;

  if (!studentId) {
    return res.status(400).json({
      success: false,
      message: 'Student ID is required',
    });
  }

  try {
    // Get the video
    const videoResult = await db.query(
      `SELECT v.*, c.id as course_id
      FROM videos v
      JOIN courses c ON v.course_id = c.id
      WHERE v.id = $1`,
      [req.params.id]
    );

    if (videoResult.rows.length === 0) {
      return res.status(404).json({
        success: false,
        message: 'Video not found',
      });
    }

    const video = videoResult.rows[0];

    // Check if the student is enrolled
    const enrollmentResult = await db.query(
      `SELECT id FROM enrollments 
      WHERE student_id = $1 AND course_id = $2`,
      [studentId, video.course_id]
    );

    if (enrollmentResult.rows.length === 0) {
      return res.status(403).json({
        success: false,
        message: 'Student is not enrolled in this course',
      });
    }

    const enrollmentId = enrollmentResult.rows[0].id;

    // Update progress
    const progressResult = await db.query(
      `INSERT INTO video_progress 
      (enrollment_id, video_id, last_watched_position, is_completed)
      VALUES ($1, $2, $3, $4)
      ON CONFLICT (enrollment_id, video_id) 
      DO UPDATE SET 
        last_watched_position = $3,
        is_completed = $4,
        updated_at = NOW()
      RETURNING *`,
      [enrollmentId, req.params.id, position, isCompleted]
    );

    // Update course progress if video is completed
    if (isCompleted) {
      // Count all completed videos
      const completedResult = await db.query(
        `SELECT COUNT(*) 
        FROM video_progress 
        WHERE enrollment_id = $1 AND is_completed = true`,
        [enrollmentId]
      );

      // Count total videos in the course
      const totalResult = await db.query(
        `SELECT COUNT(*) 
        FROM videos 
        WHERE course_id = $1`,
        [video.course_id]
      );

      const completedCount = parseInt(completedResult.rows[0].count);
      const totalCount = parseInt(totalResult.rows[0].count);
      const progressPercentage = Math.round((completedCount / totalCount) * 100);

      // Update enrollment progress
      await db.query(
        `UPDATE enrollments 
        SET progress_percentage = $1,
        updated_at = NOW()
        WHERE id = $2`,
        [progressPercentage, enrollmentId]
      );

      // Update course_progress table
      await db.query(
        `INSERT INTO course_progress 
        (enrollment_id, videos_completed, total_videos, completion_date)
        VALUES ($1, $2, $3, CASE WHEN $2 = $3 THEN NOW() ELSE NULL END)
        ON CONFLICT (enrollment_id) 
        DO UPDATE SET 
          videos_completed = $2,
          total_videos = $3,
          last_activity_date = NOW(),
          completion_date = CASE WHEN $2 = $3 THEN NOW() ELSE course_progress.completion_date END,
          updated_at = NOW()`,
        [enrollmentId, completedCount, totalCount]
      );
    }

    res.json({
      success: true,
      progress: progressResult.rows[0],
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error',
      error: error.message,
    });
  }
};

module.exports = {
  uploadVideo,
  getCourseVideos,
  getVideo,
  updateVideo,
  deleteVideo,
  updateProgress,
}; 